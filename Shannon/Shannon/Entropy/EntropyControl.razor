@using MudBlazor
@using Xyaneon.Bioinformatics.FASTA
@using Xyaneon.Bioinformatics.FASTA.IO
@using System.Diagnostics
@using System.Runtime.CompilerServices
@using Blazorise.Charts
@using ShannonEntropyCal
@using Color = MudBlazor.Color
@using System.ComponentModel
@using MudBlazor.Utilities
@using Newtonsoft.Json
@inject IJSRuntime JS

@page "/entropy"

<MudContainer>
 
    <MudExpansionPanels MultiExpansion="true">
        <MudExpansionPanel Text="1. Load data" >
            <MudText Typo="Typo.body1">Load data by uploading file...</MudText>
            <InputFile id="fileInput" OnChange="@StartLoadingFiles" hidden multiple/>
            <MudButton HtmlTag="label"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Filled.CloudUpload"
                       for="fileInput">
                Upload Files
            </MudButton>
            <br/>
            <MudText Typo="Typo.body1"> ...or by text:</MudText>
            <MudTextField T="string" Label="Sequences in fasta format"  Variant="Variant.Outlined" @bind-Value="@_inputText" Lines="15"/>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary" OnClick="@(() => OnRead(_inputText))">
                Read
            </MudButton>
            @if (_isLoading)
            {
                <p>Loading...</p>
            }
        </MudExpansionPanel>

        <MudExpansionPanel Text="2. Choose sequence">
          
        @if (_fastaReader.Sequences.Count() != 0)
        {
            <MudPaper Width="300px">
                <MudList Clickable="true">
                @foreach (var seq in _fastaReader.Sequences)
                {
                    <MudListItem AdornmentColor="Color.Primary"> @seq.Header.ToString()
                        <br/>
                        @if (ChoosenSequence == seq.Header.ToString() || _chartSeqences.ToArray().Any(x => x.name == seq.Header.ToString()))
                        {
                            @if (_chartSeqences.ToArray().Any(x => x.name == seq.Header.ToString()))
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => StartAddOrRemoveFromChart(seq.Header.ToString()))" Color="Color.Primary">Unload</MudButton>
                            }
                            else
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => ClearChart())" Color="Color.Primary">Clear</MudButton>
                            }

                        }
                        else
                        {
                            @if (ChoosenSequence == "")
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => OnStartGeneratePlot(seq.Header.ToString()))" Color="Color.Primary">Add to chart</MudButton>
                            }
                            else
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => StartAddOrRemoveFromChart(seq.Header.ToString()))" Color="Color.Primary">Add to chart</MudButton>
                            }
                        }
                        <MudDivider/>
                    </MudListItem>
                }
                </MudList>
            </MudPaper>
        }
        </MudExpansionPanel>
        <MudExpansionPanel Text="3. Set range" MaxHeight="1000">
            <MudTextField @bind-Value="StartRange" Label="Starting nucleotide" Variant="Variant.Text"></MudTextField>
            <MudTextField @bind-Value="EndRange" Label="Ending nucleotide" Variant="Variant.Text"></MudTextField>
        </MudExpansionPanel>
       
    </MudExpansionPanels>

 
    


<br/>

<MudButton Variant="Variant.Filled" OnClick="@HandleRedraw" Color="Color.Primary">Change range</MudButton>

</MudContainer>






      
@if (PlotShow)
{
    <div id="LineChart" ></div>
}

@code {
    public class ChartData
    {
        
        public double[] x = new double[0];
        public double[] y = new double[0];
        public string mode = "lines";
        public string name = "";
    }
    List<ChartData> lineChart = new List<ChartData>();
    private List<IBrowserFile> loadedFiles = new();
    private string _inputText = "";
    private long maxFileSize = 1024 * 1024 * 15;
    private bool _isLoading = false;
    public int StartRange { get; set; }

    public int EndRange
    {
        get
        {
            if (_endRange != 0) return _endRange;
            int size = 0;
            foreach (var seq in _chartSeqences)
            {
                if (seq.seq.Score.Count > size)
                    size = seq.seq.Score.Count;
            }
            return size;

        }
        set => _endRange = value;
    }

    public class CurrentSequencesOnChart
    {
        public string name = "";
        public SequenceEntropy seq = new SequenceEntropy();
    }
    private int _index = -1; //default value cannot be 0 -> first selectedindex is 0.
    private FastaReader _fastaReader = new FastaReader();
    private int _subsequenceLength = 18;
    private List<CurrentSequencesOnChart> _chartSeqences = new List<CurrentSequencesOnChart>();
    private int _endRange;

    public bool PlotShow { get; set; } = true;
    public string ChoosenSequence { get; set; } = "";


    private async Task ClearChart()
    {
        _chartSeqences.Clear();
        ChoosenSequence = "";
        await Task.Run(HandleRedraw);
    }

    private async Task AddOrRemoveFromChart(string seqname)
    {
        if (_chartSeqences.All(x => x.name != seqname))
        {
            _chartSeqences.Add(new CurrentSequencesOnChart() { name = seqname, seq = OnCalculateSequence(seqname) });
            await Task.Run(HandleRedraw);
        }
        else
        {
            var tmp = _chartSeqences.Where(x => x.name == seqname);

            var tmpchart = _chartSeqences;
            foreach (var item in tmp.ToArray())
            {
                tmpchart.Remove(item);
            }
            _chartSeqences = tmpchart;
            await Task.Run(HandleRedraw);
        }
    }
    private async Task StartAddOrRemoveFromChart(string seqname)
    {
        _isLoading = true;
        await Task.Run(()=>AddOrRemoveFromChart(seqname));
    }

    private void ReadFromText(string text)
    {
        _fastaReader.ReadMultipleFromString(text);
        _isLoading = false;
    }

    private async Task OnRead(string text)
    {
        _isLoading = true;
        await Task.Run(()=>ReadFromText(text));
    }
    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        var tmp = e.File.OpenReadStream(maxFileSize);
        StreamReader reader = new StreamReader(tmp);
        string text = await reader.ReadToEndAsync();
        _fastaReader.ReadMultipleFromString(text);
        _isLoading = false;
    }
    private async Task StartLoadingFiles(InputFileChangeEventArgs e)
    {
        if (e.FileCount != 1) return;
        if (!e.File.Name.EndsWith(".fasta")) return;
        _isLoading = true;
        await Task.Run(()=>LoadFiles(e));
    }


    public List<double> GetEntropyScoreList(SequenceEntropy seqentEntropy)
    {

        int counter = 1;
        List<double> retList = new List<double>();
        foreach (var sc in seqentEntropy.Score)
        {
            if (counter >= StartRange &&
                counter <= EndRange)
            {
                retList.Add(sc);
            }
            counter++;
        }
        return retList;
    }
    private async Task GeneratingPlot(SequenceEntropy seqentEntropy)
    {
        _chartSeqences.Clear();
        _chartSeqences.Add(new CurrentSequencesOnChart(){name = seqentEntropy.Name,seq = seqentEntropy});
        await HandleRedraw();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleRedraw();
        }
    }

    async Task HandleRedraw()
    {

        lineChart.Clear();
        foreach (var seq in _chartSeqences)
        {
            var list = GetEntropyScoreList(seq.seq);
            List<double> yAxis = new List<double>();
            int tmp = 0;
            foreach (var counter in list)
            {
                yAxis.Add(tmp);
                tmp++;
            }

            ChartData chartData = new ChartData()
            {
                x = yAxis.ToArray(),
                y = list.ToArray(),
                mode = "scatter",
                name = seq.name
            };
            lineChart.Add(chartData);
        }
        string json = JsonConvert.SerializeObject(lineChart);
        await JS.InvokeVoidAsync("test",json);


        _isLoading = false;
        StateHasChanged();
   
    }

    private async Task OnStartGeneratePlot(string seqname)
    {
        _isLoading = true;
        ChoosenSequence = seqname;
        await Task.Run(()=>OnGeneratePlot(seqname));
    }
    private async Task OnGeneratePlot(string seqname)
    {
        await GeneratingPlot(OnCalculateSequence(seqname));
       
    }
    private SequenceEntropy OnCalculateSequence(string seqname)
    {
        SequenceEntropy seqentEntropy = new SequenceEntropy();
        var sequence = _fastaReader.Sequences.SingleOrDefault(x => x.Header.ToString() == seqname);
        if (sequence != null)
        {
            string seq = sequence.Data.ToMultilineString();
            EntropyCal ent = new EntropyCal();

            seqentEntropy.Name = seqname;
            for (int index = 0; index < seq.Length; index++)
            {
                if ((_subsequenceLength + index) < seq.Length)
                {
                    var substr = seq.Substring(index, _subsequenceLength);

                    seqentEntropy.Score.Add(Math.Truncate(ent.EntropyValue(substr) * 100) / 100);
                }
            }

        }
        return seqentEntropy;


    }

    public void DisplayInConsole(object obj)
    {
        Type objtype = obj.GetType();
        var properties = objtype.GetProperties();

        foreach (var property in properties)
        {
            var propValue = property.GetValue(obj);
            var propType = propValue.GetType();

            if (propType.IsPrimitive || propType == typeof(string))
            {
                Console.WriteLine($"{property.Name} : {propValue}");
            }
        }
    }
}
