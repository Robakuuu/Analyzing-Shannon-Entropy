@using MudBlazor
@using Xyaneon.Bioinformatics.FASTA
@using Xyaneon.Bioinformatics.FASTA.IO
@using ShannonEntropyCal
@using System.Diagnostics
@using Blazorise.Charts
@using Color = MudBlazor.Color

@page "/entropy"
<h3>EntropyControl</h3>
<MudThemeProvider />
<InputFile OnChange="@LoadFiles" multiple />

<MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="@(async () => await HandleRedraw())" > Show Loading result</MudButton>

<MudPaper Width="300px">
    <MudList Clickable="true">
        @foreach (var seq in _fastaReader.Sequences)
        {
            <MudListItem AdornmentColor="Color.Primary" Text=@seq.Header.ToString() OnClick="@(()=>OnGeneratePlot(seq.Header.ToString()))"/>
            <MudDivider/>
        }
    </MudList>
</MudPaper>

<MudTextField @bind-Value="StartRange" Label="Starting nucleotide" Variant="Variant.Text"></MudTextField>
<MudTextField @bind-Value="EndRange" Label="Ending nucleotide" Variant="Variant.Text"></MudTextField>

@if (PlotGenerating)
{
    <MudProgressLinear Color="Color.Primary" Value="@Value" Class="my-7" />
    <LineChart @ref="lineChart" TItem="double" />
        
        
    

}
@code {

    public MudTheme Theme = new()
    {
        Palette = new Palette()
        {
            Primary = Colors.Blue.Default
        }
    };

    LineChart<double> lineChart = new LineChart<double>();
    private List<IBrowserFile> loadedFiles = new();
    private long maxFileSize = 1024 * 1024 * 15;
    private int maxAllowedFiles = 3;
    private bool isLoading;
    private decimal progressPercent;
    public int StartRange { get; set; }
    public int EndRange { get; set; }



    LineChartDataset<double> GetLineChartDataset()
    {
        return new LineChartDataset<double>
        {
            Label = "# of randoms",
            Data = _chartValues,
            BackgroundColor = backgroundColors,
            BorderColor = borderColors,
            Fill = true,
            PointRadius = 3,
            CubicInterpolationMode = "monotone",
        };
    }
    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        if (e.FileCount != 1) return;
        if (!e.File.Name.EndsWith(".fasta")) return;
        var tmp = e.File.OpenReadStream(maxFileSize);
        StreamReader reader = new StreamReader(tmp);
        string text = await reader.ReadToEndAsync();
        _fastaReader.ReadMultipleFromString(text);
    }
    List<string> Labels = new List<string>();
    List<string> backgroundColors = new List<string> { ChartColor.FromRgba( 255, 99, 132, 0.2f ), ChartColor.FromRgba( 54, 162, 235, 0.2f ), ChartColor.FromRgba( 255, 206, 86, 0.2f ), ChartColor.FromRgba( 75, 192, 192, 0.2f ), ChartColor.FromRgba( 153, 102, 255, 0.2f ), ChartColor.FromRgba( 255, 159, 64, 0.2f ) };
    List<string> borderColors = new List<string> { ChartColor.FromRgba( 255, 99, 132, 1f ), ChartColor.FromRgba( 54, 162, 235, 1f ), ChartColor.FromRgba( 255, 206, 86, 1f ), ChartColor.FromRgba( 75, 192, 192, 1f ), ChartColor.FromRgba( 153, 102, 255, 1f ), ChartColor.FromRgba( 255, 159, 64, 1f ) };

    private int _index = -1; //default value cannot be 0 -> first selectedindex is 0.
    private FastaReader _fastaReader = new FastaReader();
    private int _subsequenceLength = 18;
    private List<double> _chartValues = new List<double>();

    public bool PlotGenerating { get; set; }
    public bool PlotGenerated { get; set; }
    public int Value { get; set; }

    private async void GeneratingPlot(SequenceEntropy seqentEntropy)
    {
    //_chartValues = seqentEntropy.Score;
    
        List<string> tmp = new List<string>();
        int counter = 1;
        _chartValues.Clear();
       foreach (var sc in seqentEntropy.Score)
       {
           if (counter >= StartRange &&
               counter <= EndRange)
           {
               _chartValues.Add(sc);
               tmp.Add(counter.ToString());
           }
           counter++;
       }
        Labels = tmp;
        PlotGenerated = true;

    }

    async Task HandleRedraw()
    {
        await lineChart.Clear();

        await lineChart.AddLabelsDatasetsAndUpdate( Labels, GetLineChartDataset() );

    }
    bool _disposed;
    public void Dispose() => _disposed = true;
    public async void SimulateProgress()
    {
        Value = 0;
        do
        {
            if (_disposed)
            {
                return;
            }

            Value += 4;
           InvokeAsync(()=>StateHasChanged());

        } while (Value < 100);
    }
    private async Task OnGeneratePlot(string seqname)
    {
        Value = 0;
        Task.Run(()=>SimulateProgress());
        PlotGenerated = false;
        PlotGenerating = true;
        await Task.Run(async ()=>  GeneratingPlot(OnCalculateSequence(seqname)));
        StateHasChanged();
    }
    private SequenceEntropy OnCalculateSequence(string seqname)
    {
        SequenceEntropy seqentEntropy = new SequenceEntropy();
        var sequence = _fastaReader.Sequences.SingleOrDefault(x => x.Header.ToString() == seqname);
        if (sequence != null)
        {
            string seq = sequence.Data.ToMultilineString();
            EntropyCal ent = new EntropyCal();
           
            seqentEntropy.Name = seqname;
            for (int index = 0; index < seq.Length; index++)
            {
                if ((_subsequenceLength + index) < seq.Length)
                {
                    var substr = seq.Substring(index, _subsequenceLength);

                    seqentEntropy.Score.Add(Math.Truncate(ent.EntropyValue(substr) * 100) / 100);
                }
            }

        }
        return seqentEntropy;


    }

    public void DisplayInConsole(object obj)
    {
        Type objtype = obj.GetType();
        var properties = objtype.GetProperties();

        foreach (var property in properties)
        {
            var propValue = property.GetValue(obj);
            var propType = propValue.GetType();

            if (propType.IsPrimitive || propType == typeof(string))
            {
                Console.WriteLine($"{property.Name} : {propValue}");
            }
        }
    }
}
