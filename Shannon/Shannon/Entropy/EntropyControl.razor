@using MudBlazor
@using Xyaneon.Bioinformatics.FASTA
@using Xyaneon.Bioinformatics.FASTA.IO
@using System.Diagnostics
@using System.Runtime.CompilerServices
@using Blazorise.Charts
@using ShannonEntropyCal
@using Color = MudBlazor.Color
@using System.ComponentModel
@using MudBlazor.Utilities

@page "/entropy"

<MudContainer>
 
    <MudExpansionPanels MultiExpansion="true">
        <MudExpansionPanel Text="1. Load data" >
            <MudText Typo="Typo.body1">Load data by uploading file...</MudText>
            <InputFile id="fileInput" OnChange="@StartLoadingFiles" hidden multiple/>
            <MudButton HtmlTag="label"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Filled.CloudUpload"
                       for="fileInput">
                Upload Files
            </MudButton>
            <br/>
            <MudText Typo="Typo.body1"> ...or by text:</MudText>
            <MudTextField T="string" Label="Sequences in fasta format"  Variant="Variant.Outlined" @bind-Value="@_inputText" Lines="15"/>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary" OnClick="@(() => OnRead(_inputText))">
                Read
            </MudButton>
            @if (isLoading)
            {
                <p>Loading...</p>
            }
        </MudExpansionPanel>

        <MudExpansionPanel Text="2. Choose sequence">
          
        @if (_fastaReader.Sequences.Count() != 0)
        {
            <MudPaper Width="300px">
                <MudList Clickable="true">
                @foreach (var seq in _fastaReader.Sequences)
                {
                    <MudListItem AdornmentColor="Color.Primary"> @seq.Header.ToString()
                        <br/>
                        @if (ChoosenSequence == seq.Header.ToString() || chartSeqences.ToArray().Any(x => x.name == seq.Header.ToString()))
                        {
                            @if (chartSeqences.ToArray().Any(x => x.name == seq.Header.ToString()))
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => StartAddOrRemoveFromChart(seq.Header.ToString()))" Color="Color.Primary">Unload</MudButton>
                            }
                            else
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => ClearChart())" Color="Color.Primary">Clear</MudButton>
                            }

                        }
                        else
                        {
                            @if (ChoosenSequence == "")
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => OnStartGeneratePlot(seq.Header.ToString()))" Color="Color.Primary">Add to chart</MudButton>
                            }
                            else
                            {
                                <MudButton Variant="Variant.Filled" OnClick="@(() => StartAddOrRemoveFromChart(seq.Header.ToString()))" Color="Color.Primary">Add to chart</MudButton>
                            }
                        }
                        <MudDivider/>
                    </MudListItem>
                }
                </MudList>
            </MudPaper>
        }
        </MudExpansionPanel>
        <MudExpansionPanel Text="3. Set range" MaxHeight="1000">
            <MudTextField @bind-Value="StartRange" Label="Starting nucleotide" Variant="Variant.Text"></MudTextField>
            <MudTextField @bind-Value="EndRange" Label="Ending nucleotide" Variant="Variant.Text"></MudTextField>
        </MudExpansionPanel>
       
    </MudExpansionPanels>

 
    


<br/>

<MudButton Variant="Variant.Filled" OnClick="@(() => OnStartGeneratePlot(@ChoosenSequence))" Color="Color.Primary">Change range</MudButton>

</MudContainer>






      
@if (PlotShow)
{
    <LineChart @ref="lineChart" TItem="double" />
}

@code {

    LineChart<double> lineChart = new LineChart<double>();
    private List<IBrowserFile> loadedFiles = new();
    private string _inputText = "";
    private long maxFileSize = 1024 * 1024 * 15;
    private int maxAllowedFiles = 3;
    private bool isLoading = false;
    private decimal progressPercent;
    public int StartRange { get; set; }
    public int EndRange { get; set; }
    List<string> Labels = new List<string>();
    List<string> backgroundColors = new List<string> { ChartColor.FromRgba(255, 99, 132, 0.2f), ChartColor.FromRgba(54, 162, 235, 0.2f), ChartColor.FromRgba(255, 206, 86, 0.2f), ChartColor.FromRgba(75, 192, 192, 0.2f), ChartColor.FromRgba(153, 102, 255, 0.2f), ChartColor.FromRgba(255, 159, 64, 0.2f) };
    List<string> borderColors = new List<string> { ChartColor.FromRgba(255, 99, 132, 1f), ChartColor.FromRgba(54, 162, 235, 1f), ChartColor.FromRgba(255, 206, 86, 1f), ChartColor.FromRgba(75, 192, 192, 1f), ChartColor.FromRgba(153, 102, 255, 1f), ChartColor.FromRgba(255, 159, 64, 1f) };

    public class CurrentSequencesOnChart
    {
        public string name = "";
        public SequenceEntropy seq = new SequenceEntropy();
    }
    private int _index = -1; //default value cannot be 0 -> first selectedindex is 0.
    private FastaReader _fastaReader = new FastaReader();
    private int _subsequenceLength = 18;
    private List<double> _chartValues = new List<double>();
    private List<CurrentSequencesOnChart> chartSeqences = new List<CurrentSequencesOnChart>();

    public bool PlotShow { get; set; } = true;
    public string ChoosenSequence { get; set; } = "";


    LineChartDataset<double> GetLineChartDataset(List<double> values,string seqname="")
    {
        return new LineChartDataset<double>
            {
                Label = seqname,
                Data = values,
                BackgroundColor = backgroundColors,
                BorderColor = borderColors,
                Fill = true,
                PointRadius = 3,
                CubicInterpolationMode = "monotone"
            };
    }

    private bool CheckIdDataAreLoaded()
    {
        return _fastaReader.Sequences.Any();
    }
    private async Task ClearChart()
    {
        chartSeqences.Clear();
        _chartValues.Clear();
        ChoosenSequence = "";
        await Task.Run(HandleRedraw);
    }

    private async Task AddOrRemoveFromChart(string seqname)
    {
        if (chartSeqences.All(x => x.name != seqname))
        {
            chartSeqences.Add(new CurrentSequencesOnChart() { name = seqname, seq = OnCalculateSequence(seqname) });
            await Task.Run(HandleRedraw);
        }
        else
        {
            var tmp = chartSeqences.Where(x => x.name == seqname);

            var tmpchart = chartSeqences;
            foreach (var item in tmp.ToArray())
            {
                tmpchart.Remove(item);
            }
            chartSeqences = tmpchart;
            await Task.Run(HandleRedraw);
        }
    }
    private async Task StartAddOrRemoveFromChart(string seqname)
    {
        isLoading = true;
        await Task.Run(()=>AddOrRemoveFromChart(seqname));
    }

    private void ReadFromText(string text)
    {
        _fastaReader.ReadMultipleFromString(text);
        isLoading = false;
    }

    private async Task OnRead(string text)
    {
        isLoading = true;
        await Task.Run(()=>ReadFromText(text));
    }
    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        var tmp = e.File.OpenReadStream(maxFileSize);
        StreamReader reader = new StreamReader(tmp);
        string text = await reader.ReadToEndAsync();
        _fastaReader.ReadMultipleFromString(text);
        isLoading = false;
    }
    private async Task StartLoadingFiles(InputFileChangeEventArgs e)
    {
        if (e.FileCount != 1) return;
        if (!e.File.Name.EndsWith(".fasta")) return;
        isLoading = true;
        await Task.Run(()=>LoadFiles(e));
    }


    public List<double> GetEntropyScoreList(SequenceEntropy seqentEntropy)
    {

        int counter = 1;
        List<double> retList = new List<double>();
        foreach (var sc in seqentEntropy.Score)
        {
            if (counter >= StartRange &&
                counter <= EndRange)
            {
                retList.Add(sc);
            }
            counter++;
        }
        return retList;
    }
    private async Task GeneratingPlot(SequenceEntropy seqentEntropy)
    {
        List<string> tmp = new List<string>();
        int counter = 1;
        _chartValues.Clear();
        foreach (var sc in seqentEntropy.Score)
        {
            if (counter >= StartRange &&
                counter <= EndRange)
            {
                _chartValues.Add(sc);
                tmp.Add(counter.ToString());
            }
            counter++;
        }
        Labels = tmp;

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleRedraw();
        }
    }

    async Task HandleRedraw()
    {

        await lineChart.Clear();
        foreach (var seq in chartSeqences)
        {
            await lineChart.AddDataSet(GetLineChartDataset(GetEntropyScoreList(seq.seq),seq.name));
        }
        await lineChart.AddLabelsDatasetsAndUpdate(Labels, GetLineChartDataset(_chartValues,ChoosenSequence));


        isLoading = false;
        //await InvokeAsync(StateHasChanged);
    }

    private async Task OnStartGeneratePlot(string seqname)
    {
        isLoading = true;
        ChoosenSequence = seqname;
        await Task.Run(()=>OnGeneratePlot(seqname));
    }
    private async Task OnGeneratePlot(string seqname)
    {
        await GeneratingPlot(OnCalculateSequence(seqname));
        await HandleRedraw();
    }
    private SequenceEntropy OnCalculateSequence(string seqname)
    {
        SequenceEntropy seqentEntropy = new SequenceEntropy();
        var sequence = _fastaReader.Sequences.SingleOrDefault(x => x.Header.ToString() == seqname);
        if (sequence != null)
        {
            string seq = sequence.Data.ToMultilineString();
            EntropyCal ent = new EntropyCal();

            seqentEntropy.Name = seqname;
            for (int index = 0; index < seq.Length; index++)
            {
                if ((_subsequenceLength + index) < seq.Length)
                {
                    var substr = seq.Substring(index, _subsequenceLength);

                    seqentEntropy.Score.Add(Math.Truncate(ent.EntropyValue(substr) * 100) / 100);
                }
            }

        }
        return seqentEntropy;


    }

    public void DisplayInConsole(object obj)
    {
        Type objtype = obj.GetType();
        var properties = objtype.GetProperties();

        foreach (var property in properties)
        {
            var propValue = property.GetValue(obj);
            var propType = propValue.GetType();

            if (propType.IsPrimitive || propType == typeof(string))
            {
                Console.WriteLine($"{property.Name} : {propValue}");
            }
        }
    }
}
